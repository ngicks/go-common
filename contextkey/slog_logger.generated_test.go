// Code generated by github.com/ngicks/go-common/contextkey/generate DO NOT EDIT
package contextkey

import (
	"context"
	"testing"
	"log/slog"
)

func TestSlogLogger(t *testing.T) {
	var zero *slog.Logger

	ctx := context.Background()

	if v := ctx.Value(KeySlogLogger); v != nil {
		t.Fatalf("there is value for key %v", KeySlogLogger)
	}

	noDefaultValue := func() *slog.Logger { return new(slog.Logger) }() 
	ctx = WithSlogLogger(ctx, noDefaultValue)

	v1 := ctx.Value(KeySlogLogger)
	if v1 == nil {
		t.Fatalf("no value for key %v", KeySlogLogger)
	}
	if _, ok := v1.(*slog.Logger); !ok {
		t.Fatalf("different type associated, want = %s, got = %T", "*slog.Logger", v1)
	}

	getAndCompare := func(eq bool) func(v2 *slog.Logger, ok bool) {
		return func(v2 *slog.Logger, ok bool) {
			t.Helper()
			not := "not "
			if eq {
				not = ""
			}
			if ok != eq {
				t.Fatalf("different type associated, want = %s%s, got = %T", not, "*slog.Logger", v1)
			}

			if func (v1, v2 any) bool { return v1 == v2 }(v1, v2) != eq {
				t.Fatalf("wrong value retrieved, want = %s%v, got = %v", not, v1, v2)
			}
		}
	}

	getAndCompare(true)(ValueSlogLogger(ctx))
	getAndCompare(true)(ValueSlogLoggerFallback(ctx, zero), true)
	getAndCompare(true)(ValueSlogLoggerFallbackFn(ctx, func() *slog.Logger { return zero }), true)
	getAndCompare(true)(ValueSlogLoggerDefault(ctx), true)

	ctx = context.WithValue(ctx, KeySlogLogger, struct{}{})
	getAndCompare(false)(ValueSlogLogger(ctx))
	getAndCompare(false)(ValueSlogLoggerFallback(ctx, zero), false)
	getAndCompare(false)(ValueSlogLoggerFallbackFn(ctx, func() *slog.Logger { return zero }), false)
	getAndCompare(false)(ValueSlogLoggerDefault(ctx), false)

	ctx = context.Background()
	getAndCompare(false)(ValueSlogLogger(ctx))
	getAndCompare(false)(ValueSlogLoggerFallback(ctx, zero), false)
	getAndCompare(false)(ValueSlogLoggerFallbackFn(ctx, func() *slog.Logger { return zero }), false)
	getAndCompare(false)(ValueSlogLoggerDefault(ctx), false)

	if v := ValueSlogLoggerFallback(ctx, noDefaultValue); !func (v1, v2 any) bool { return v1 == v2 }(v, noDefaultValue) {
		t.Fatalf("ValueSlogLoggerFallback did not fall back correctly. want = %v, got = %v", noDefaultValue, v)
	}
	if v := ValueSlogLoggerFallbackFn(ctx, func() *slog.Logger { return noDefaultValue }); !func (v1, v2 any) bool { return v1 == v2 }(v, noDefaultValue) {
		t.Fatalf("ValueSlogLoggerFallbackFn did not fall back correctly. want = %v, got = %v", noDefaultValue, v)
	}

	v := ValueSlogLoggerDefault(ctx)
	if !func (v1, v2 any) bool { return v1 == v2 }(v, slog.Default()) {
		def1, def2 := slog.Default(), slog.Default()
		if  !func (v1, v2 any) bool { return v1 == v2 }(def1, def2) {
			t.Logf("default value is non-deterministic; You must implement your own test for ValueSlogLoggerDefault(ctx)")
		} else {
			t.Fatalf("ValueSlogLoggerDefault did not fall back to default value")
		}
	}
}