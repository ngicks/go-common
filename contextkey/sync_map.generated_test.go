// Code generated by github.com/ngicks/go-common/contextkey/generate DO NOT EDIT
package contextkey

import (
	"context"
	"testing"
	"sync"
)

func TestSyncMap(t *testing.T) {
	var zero *sync.Map

	ctx := context.Background()

	if v := ctx.Value(KeySyncMap); v != nil {
		t.Fatalf("there is value for key %v", KeySyncMap)
	}

	noDefaultValue := func() *sync.Map { var m sync.Map; m.Store("foo", "bar"); return &m }() 
	ctx = WithSyncMap(ctx, noDefaultValue)

	v1 := ctx.Value(KeySyncMap)
	if v1 == nil {
		t.Fatalf("no value for key %v", KeySyncMap)
	}
	if _, ok := v1.(*sync.Map); !ok {
		t.Fatalf("different type associated, want = %s, got = %T", "*sync.Map", v1)
	}

	getAndCompare := func(eq bool) func(v2 *sync.Map, ok bool) {
		return func(v2 *sync.Map, ok bool) {
			t.Helper()
			not := "not "
			if eq {
				not = ""
			}
			if ok != eq {
				t.Fatalf("different type associated, want = %s%s, got = %T", not, "*sync.Map", v1)
			}

			if equalSyncMap(v1, v2) != eq {
				t.Fatalf("wrong value retrieved, want = %s%v, got = %v", not, v1, v2)
			}
		}
	}

	getAndCompare(true)(ValueSyncMap(ctx))
	getAndCompare(true)(ValueSyncMapFallback(ctx, zero), true)
	getAndCompare(true)(ValueSyncMapFallbackFn(ctx, func() *sync.Map { return zero }), true)
	getAndCompare(true)(ValueSyncMapDefault(ctx), true)

	ctx = context.WithValue(ctx, KeySyncMap, struct{}{})
	getAndCompare(false)(ValueSyncMap(ctx))
	getAndCompare(false)(ValueSyncMapFallback(ctx, zero), false)
	getAndCompare(false)(ValueSyncMapFallbackFn(ctx, func() *sync.Map { return zero }), false)
	getAndCompare(false)(ValueSyncMapDefault(ctx), false)

	ctx = context.Background()
	getAndCompare(false)(ValueSyncMap(ctx))
	getAndCompare(false)(ValueSyncMapFallback(ctx, zero), false)
	getAndCompare(false)(ValueSyncMapFallbackFn(ctx, func() *sync.Map { return zero }), false)
	getAndCompare(false)(ValueSyncMapDefault(ctx), false)

	if v := ValueSyncMapFallback(ctx, noDefaultValue); !equalSyncMap(v, noDefaultValue) {
		t.Fatalf("ValueSyncMapFallback did not fall back correctly. want = %v, got = %v", noDefaultValue, v)
	}
	if v := ValueSyncMapFallbackFn(ctx, func() *sync.Map { return noDefaultValue }); !equalSyncMap(v, noDefaultValue) {
		t.Fatalf("ValueSyncMapFallbackFn did not fall back correctly. want = %v, got = %v", noDefaultValue, v)
	}

	v := ValueSyncMapDefault(ctx)
	if !equalSyncMap(v, new(sync.Map)) {
		def1, def2 := new(sync.Map), new(sync.Map)
		if  !equalSyncMap(def1, def2) {
			t.Logf("default value is non-deterministic; You must implement your own test for ValueSyncMapDefault(ctx)")
		} else {
			t.Fatalf("ValueSyncMapDefault did not fall back to default value")
		}
	}
}